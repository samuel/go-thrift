// This file is automatically generated. Do not modify.

package gentest

import (
	"fmt"
	"strconv"
)

var _ = fmt.Sprintf

type ResultCode int32

const (
	ResultCodeOk       ResultCode = 0
	ResultCodeTryLater ResultCode = 1
)

var (
	ResultCodeByName = map[string]ResultCode{
		"ResultCode.OK":        ResultCodeOk,
		"ResultCode.TRY_LATER": ResultCodeTryLater,
	}
	ResultCodeByValue = map[ResultCode]string{
		ResultCodeOk:       "ResultCode.OK",
		ResultCodeTryLater: "ResultCode.TRY_LATER",
	}
)

func (e ResultCode) String() string {
	name := ResultCodeByValue[e]
	if name == "" {
		name = fmt.Sprintf("Unknown enum value ResultCode(%d)", e)
	}
	return name
}

func (e ResultCode) MarshalJSON() ([]byte, error) {
	name := ResultCodeByValue[e]
	if name == "" {
		name = strconv.Itoa(int(e))
	}
	return []byte("\"" + name + "\""), nil
}

func (e *ResultCode) UnmarshalJSON(b []byte) error {
	st := string(b)
	if st[0] == '"' {
		*e = ResultCode(ResultCodeByName[st[1:len(st)-1]])
		return nil
	}
	i, err := strconv.Atoi(st)
	*e = ResultCode(i)
	return err
}

func (e ResultCode) Ptr() *ResultCode {
	return &e
}

type LogEntry struct {
	Category *string `thrift:"1,required" json:"category"`
	Message  *string `thrift:"2,required" json:"message"`
}

func (l *LogEntry) GetCategory() (val string) {
	if l != nil && l.Category != nil {
		return *l.Category
	}

	return
}

func (l *LogEntry) GetMessage() (val string) {
	if l != nil && l.Message != nil {
		return *l.Message
	}

	return
}

type FailedException struct {
	Reason *string `thrift:"1,required" json:"reason"`
}

func (f *FailedException) GetReason() (val string) {
	if f != nil && f.Reason != nil {
		return *f.Reason
	}

	return
}

func (e FailedException) Error() string {
	return fmt.Sprintf("FailedException{Reason: %+v}", e.GetReason())
}

type Scribe interface {
	Echo(messages *LogEntry) (*LogEntry, error)
	Log(messages []LogEntry) (*ResultCode, error)
}

type ScribeServer struct {
	Implementation Scribe
}

func (s *ScribeServer) Echo(req *InternalRPCScribeEchoRequest, res *InternalRPCScribeEchoResponse) error {
	val, err := s.Implementation.Echo(req.Messages)
	switch e := err.(type) {
	case *FailedException:
		res.F = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *ScribeServer) Log(req *InternalRPCScribeLogRequest, res *InternalRPCScribeLogResponse) error {
	val, err := s.Implementation.Log(req.Messages)
	switch e := err.(type) {
	case *FailedException:
		res.F = e
		err = nil
	}
	res.Value = val
	return err
}

type InternalRPCScribeEchoRequest struct {
	Messages *LogEntry `thrift:"1,required" json:"messages"`
}

func (i *InternalRPCScribeEchoRequest) GetMessages() (val LogEntry) {
	if i != nil && i.Messages != nil {
		return *i.Messages
	}

	return
}

type InternalRPCScribeEchoResponse struct {
	Value *LogEntry        `thrift:"0" json:"value,omitempty"`
	F     *FailedException `thrift:"1" json:"f,omitempty"`
}

func (i *InternalRPCScribeEchoResponse) GetValue() (val LogEntry) {
	if i != nil && i.Value != nil {
		return *i.Value
	}

	return
}

func (i *InternalRPCScribeEchoResponse) GetF() (val FailedException) {
	if i != nil && i.F != nil {
		return *i.F
	}

	return
}

type InternalRPCScribeLogRequest struct {
	Messages []LogEntry `thrift:"1,required" json:"messages"`
}

func (i *InternalRPCScribeLogRequest) GetMessages() (val []LogEntry) {
	if i != nil {
		return i.Messages
	}

	return
}

type InternalRPCScribeLogResponse struct {
	Value *ResultCode      `thrift:"0" json:"value,omitempty"`
	F     *FailedException `thrift:"1" json:"f,omitempty"`
}

func (i *InternalRPCScribeLogResponse) GetValue() (val ResultCode) {
	if i != nil && i.Value != nil {
		return *i.Value
	}

	return
}

func (i *InternalRPCScribeLogResponse) GetF() (val FailedException) {
	if i != nil && i.F != nil {
		return *i.F
	}

	return
}

type ScribeClient struct {
	Client RPCClient
}

func (s *ScribeClient) Echo(messages *LogEntry) (ret *LogEntry, err error) {
	req := &InternalRPCScribeEchoRequest{
		Messages: messages,
	}
	res := &InternalRPCScribeEchoResponse{}
	err = s.Client.Call("Echo", req, res)
	if err == nil {
		switch {
		case res.F != nil:
			err = res.F
		}
	}
	if err == nil {
		ret = res.Value
	}
	return
}

func (s *ScribeClient) Log(messages []LogEntry) (ret *ResultCode, err error) {
	req := &InternalRPCScribeLogRequest{
		Messages: messages,
	}
	res := &InternalRPCScribeLogResponse{}
	err = s.Client.Call("Log", req, res)
	if err == nil {
		switch {
		case res.F != nil:
			err = res.F
		}
	}
	if err == nil {
		ret = res.Value
	}
	return
}
